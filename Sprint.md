EXPLICACIÓN:

¿ Qué se hizo ?
Durante el Sprint 1, el equipo transformó un listado de productos estático en un sistema dinámico, utilizando Git, GitHub y la metodología Scrum. Con el objetivo de mantener la estabilidad del proyecto, no se trabajó directamente sobre la rama main, sino que se utilizó la rama develop como base de integración. Cada desarrollador trabajó en su propia rama feature, lo que permitió el desarrollo en paralelo sin sobrescribir el trabajo de otros integrantes.
Para la implementación técnica, se decidió modularizar el proyecto aplicando el principio de separación de responsabilidades. El código fue dividido en archivos especializados: data.js para el manejo de los datos, render.js para la renderización dinámica de los productos en el DOM, agregar.js para la lógica de creación y validación de productos, y app.js como punto de entrada de la aplicación. Además, se utilizaron módulos ES6 mediante la sintaxis import/export, lo que permitió una estructura de código más ordenada, reutilizable y profesional.

¿ Quién hizo qué ?
Durante el Sprint 1, el equipo trabajó de forma colaborativa utilizando Git, GitHub y la metodología Scrum para transformar un listado de productos estático en uno dinámico. Se decidió no trabajar directamente sobre la rama main con el objetivo de mantener la estabilidad del proyecto, utilizando la rama develop como base principal de integración.
El Product Owner (PO) definió los requerimientos del Sprint y validó que la funcionalidad desarrollada cumpliera con lo solicitado. En conjunto con el Scrum Master (SM), el PO participó en la gestión del flujo del repositorio, organizando la estructura de ramas, creando la rama develop y supervisando los procesos de integración y merge, asegurando que el código se unificara de manera correcta y sin conflictos.
Como parte de la planificación del Sprint, se creó la rama feature/create-read, la cual funcionó como la rama principal de la funcionalidad desarrollada durante el Sprint 1. En esta rama se consolidaron todas las funcionalidades implementadas, una vez que estas fueron integradas y verificadas previamente en la rama develop.
Los desarrolladores implementaron la solución técnica aplicando una separación de responsabilidades mediante módulos en JavaScript. Se creó el arreglo de productos, la función para renderizar dinámicamente el contenido en el DOM y la función para agregar nuevos productos con validación básica de campos. Para la correcta conexión entre archivos, se utilizó la sintaxis import/export de ES6, permitiendo un código más ordenado y escalable.
Cada desarrollador trabajó en su propia rama feature, desde donde posteriormente se realizaron Pull Requests hacia la rama develop. Estos Pull Requests fueron revisados y gestionados antes de realizar los merges correspondientes. Posteriormente, la rama feature/create-read fue actualizada con los cambios integrados en develop, consolidando en una sola rama todo el trabajo realizado por el equipo durante el Sprint.
Este flujo de trabajo permitió el desarrollo en paralelo, redujo el riesgo de conflictos y facilitó la identificación de los aportes individuales. Como resultado, se obtuvo un sistema funcional que renderiza productos de forma dinámica y permite agregar nuevos elementos con validación, dejando preparada la base para futuras operaciones del CRUD.

Problemas encontrados:
El botón “Agregar” no funcionaba: la función no se ejecutaba porque se usaban import/export sin cargar el script con type="module", por lo que el navegador no interpretaba los módulos.
Desincronización local - remoto: a veces no aparecían ramas o cambios en VS Code por no ejecutar git pull o no estar en la rama correcta.
Riesgo de conflictos por trabajo simultáneo: varios desarrolladores podían modificar lo mismo. Se mitigó separando el código en módulos y usando la rama feature.
Estructura de carpetas incompleta: algunos no tenían la carpeta apps por falta de actualización. Se soluciona sincronizando con develop.
Dudas en merges y Pull Requests: Hubo dudas sobre cuándo hacer merge y hacia qué rama. Se estandarizó el flujo: cada feature → Pull Request → develop, supervisado por el PO y el Scrum Master.
